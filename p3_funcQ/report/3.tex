\section*{Experiments with worst-case}

\subsection*{A standard Haskell list}
\subsection*{A pair of lists}
\subsection*{A pair of lists, exploiting laziness}
\subsection*{A $O(1)$ list}

\begin{figure}[htb]
\centering
\input{../benchmark/graphs/simple.tex}
\caption{blah}
\label{simple}
\end{figure}

\begin{figure}[htb]
\centering
\input{../benchmark/graphs/simple_high.tex}
\caption{blah}
\label{simple-high}
\end{figure}


\begin{figure}[htb]
\centering
\input{../benchmark/graphs/reuseremove_snd.tex}
\caption{blah}
\label{reuse-remove-2}
\end{figure}

The graph below looks unusual because of the way our benchmark works. In order to force the worst-case scenario of the paired lazy lists, the size of the left list has to be exactly one less than the size of the right list. Given the nature of our benchmarking framework we are stuck with whatever size we are given. Therefore we fill up the queue until the two lists are exactly the same. For any given list size its actual size is going to be one less than the subsequent exponent of 2. Since the number of insertions shrink as the size increases, the lines are declining slightly only to jump at the point where we have reached a new exponent of 2.


\begin{figure}[htb]
\centering
\input{../benchmark/graphs/reuseremove_fth.tex}
\caption{blah}
\label{reuse-remove-4}
\end{figure}

