\section*{Fibonacci Heap}
The Fibonacci heap entirely consists of pointers and only utilizes an array when the scanning of ranks is to be executed.
Each node contains four pointers. Two pointing to it's left and right siblings, one pointing at its parent and one to a child.
Having a pointer to the left and the right results in the nodes forming a doubly linked list at each level. The heap does not order the lists in any way, since a particular order depending on the rank or the key of the nodes does not have any impact on the correctness or efficiency of heap operations.
This doubly linked list allows us to extract and insert nodes in very little (constant) time. Some invariants however need to be maintained:
\begin{itemize}
 \item Extracting/deleting child nodes result in the parent being marked. If it is already marked, the parent itself has to be extracted and placed at in the root list. This cascades to the parent of that, marking it or recursing further if it is marked as well.
 \item When deleting the minimum, the heap has to clean up the root list. After this operation there exist no two root nodes with the same rank.
\end{itemize}
Some of the more curious parts of the implementation also involve the delete\_min operation. Since delete\_min is iterating a doubly linked list, which is modified while looping, the pointer to the next node is saved before any other operations begin. The loop could otherwise continue in the child list of a node already registered in the scanning array, after the current node has been made a child of it, because it had the same rank.

A custom invariant in the fibonacci heap, set and maintained by us, is the fact that there not ever exists an invalid linked list. Once a node is extracted from a list, it is immedeatly linked to itself on the left and the right. This way succeeding union operations will always be able to link the node into a new list without any dangling pointers.

The amount of memory allocated for the scanning array in the delete_min operation is directly proportional to the number of nodes in the heap. Our intuition however is, that this amount can be drastically reduced. The amount of memory needed is directly proportional to the maximum rank any root node can assume. This rank must be lower than the total number of nodes in the heap, because that node, by definition, contains sub trees of nodes. We have not investigated this further and do not have examples proving or disproving this intuition.
Minimizing the size of the scanning array would decrease the running time of the delete_min operation. This holds true, because inserting a node into the array requires us to check whether the position in the array is free. We do this by checking for the NULL pointer. The only way to ensure that a given (free) address in the array is in fact free, is to clear the allocated memory with zeroes. This is the reason we use calloc() and not malloc(), when allocating the array. calloc() however still needs to run over the entire allocated space, ostensibly taking O(n) time.
