\section*{Testing of implementations}
\subsection*{Test Setup}
 -how do we test?
 -why?
 -pros/cons.

\subsection*{Test Data}
  \subsubsection*{Graphs with many \textit{decrease key} operations} 
    Constructing a graph with many \textit{decrease key} operations is fairly easy. The problem is making sure the \textit{decrease key} operation force the Binary Heap to move the element. If the element after the \textit{decrease key} doesn't violate the Binary Heap property, it does not need to be moved and will be a constant operation, and thus it will match the Fibonacci Heap.

    The graph is generated with the following code:
    \begin{algorithm}
      \caption{\code{Generate graph} max decrease calls}
      \begin{algorithmic}[1]
	\REQUIRE number of vertices $n$
	  \FOR {$j$ := $1$; $j$ < $n$; $j$ := $j + 1$}
	    \STATE $weights[0][j]$ := $n*n -j$
	  \ENDFOR
	  \STATE $weights[0][n]$ := $1$
	  \FOR {$i$ := $n-1$; $i > 1$; $i$ := $i-1$}
	    \FOR {$j$ := $1$; $j < i$; $j$ := $j+1$}
	      \STATE $weights[i][j]$ := $n^2 - (n - i)n - j + 1$
	    \ENDFOR
	    \STATE $weights[i][i-1]$ := 1;
	  \ENDFOR
	\RETURN $weights$
\end{algorithmic}
\end{algorithm}
 \subsubsection*{Random Graphs}
