\section*{Comparison with priority queues}
The vEB tree can be used as a priority queue if we build some extra logic on top of it. Firstly a priority queue can contain several elements with the same priority, a search tree does not allow this. To get around this limitation we've build a new priority queue that can use any search tree as the underlying data structure. Ignoring intialization (this is just initializing the underlying search tree), we focus on the actual usage. Our priority queue support the following operations:

\begin{itemize}
  \item $void \textbf{ veb\_pq\_insert}(veb\_pq\_node * n, vebtree * tree)$
  \item $void \textbf{ veb\_pq\_delete}(vebtree * tree, veb\_pq\_node * node)$
  \item $veb\_pq\_node * \textbf{ veb\_pq\_deletemin}(vebtree * tree)$
  \item $void \textbf{ veb\_pq\_decrease\_key}(vebtree * tree, veb\_pq\_node * node, uint32\_t delta)$
\end{itemize}
A \textbf{veb\_pq\_data} is just a simple structure that contain a pointer to the first \textbf{veb\_pq\_node} in a linked list of nodes, and a counter, $n$ that is the number of nodes in the linked list. A \textbf{veb\_pq\_node} contains a pointer to the next and previous nodes, if any, and a pointer to the \textbf{veb\_pq\_data} holding the node; in particular, this last pointer allows us to check if a node is in the search tree or not, but seeing if the pointer is $NULL$. It also have an unsigned integer field that is the priority. Any auxilary data should also be included in this node - we just have a node number to indicate which node in the graph for our dijkstras algorithm it represent.

\subsubsection*{\textbf{veb\_pq\_insert}}


kort om BinHeap og FibHeap

We have chosen to benchmark the van Emde Boas tree with the two graph generation algorithms we implemented in the previous assignment.
Those include a random graph generator and a generator which should cause a high number of decrease\_key calls when using dijkstra on the graph to solve the single source shortest path problem.
The random graph generator generates a graph, where each vertice has a 15\% chance of being connected to another vertice with the weight being between 1 and a chosen maximum.

\input{../benchmark/graphs/random_averages_absolute.tex}

\input{../benchmark/graphs/dkmax2_averages_cycles.tex}

\input{../benchmark/graphs/random_maximum_cycles.tex}

We measured the running time using two different methods. One using normal absolute time measurement, the other one counting clock cycles. Curios to see which method had the lowest standard deviation we were surprised to discover that it increases using both methods quite rapidly as the graph sizes grow bigger.

\input{../benchmark/graphs/random_standard_deviation_absolute.tex}

The only exception being the random graph, when counting clock cycles.

\input{../benchmark/graphs/random_standard_deviation_cycles.tex}

We have yet to explain why this is happening.

hvilke test cases har vi og hvorfor?
test og plots
konklutioner p√• testne