\section*{Comparison with Red-Black Trees}
Red-Black trees are self balancing search trees, which garantee that the height of the tree is at most $2 \cdot \log n$, by ensuring that any path from the root node to a leaf contains the same number of black node and both children of any red node, are black. So in order to compare the performance, we chould use sorting, but that only test the \textbf{insert} and \textbf{delete min} operations, and we might as well just use a heap for that anyway. We will test both heaps and both search trees with sorting later, but comparison with Red-Black trees focus on stressing \textbf{find succ} and \textbf{find pred} and to some extend \textbf{insert} and \textbf{delete}.

Because the height of the vEB tree is $3$ (assuming $U = 2^{24}$ and leaf size of 64), it's almost futile effort to ensure it goes to the bottom every time we perform a \textbf{find succ} or \textbf{find pred} operation. There is simply too much overhead assosiated with it anyway, and the time complexity will not grow with the size of the input, but the universe. What is more interesting is to construct a benchmark where Red-Black trees consistently have to search a path of length $2 \cdot \log n$ for every \textbf{find succ} or \textbf{find pred}.

\subsection*{Benchmarking}

In order to compare Red-Black trees to van Emde Boas trees we constructed a simple sorting benchmark.
To do that we implemented a list generator, whose product should be sorted by either algorithm.
The generator produces a list of random numbers from 0 to a given maximum and terminates once a given size is reached.

test og plots
konklutioner p√• testne